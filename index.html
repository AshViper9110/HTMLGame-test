<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>movetest</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="controls">
      <button
        class="btn up"
        onpointerdown="keys.w=true"
        onpointerup="keys.w=false"
        ontouchcancel="keys.w=false"
        ontouchend="keys.w=false"
      >
        â†‘
      </button>
      <button
        class="btn left"
        onpointerdown="keys.a=true"
        onpointerup="keys.a=false"
        ontouchcancel="keys.a=false"
        ontouchend="keys.a=false"
      >
        â†
      </button>
      <button
        class="btn down"
        onpointerdown="keys.s=true"
        onpointerup="keys.s=false"
        ontouchcancel="keys.s=false"
        ontouchend="keys.s=false"
      >
        â†“
      </button>
      <button
        class="btn right"
        onpointerdown="keys.d=true"
        onpointerup="keys.d=false"
        ontouchcancel="keys.d=false"
        ontouchend="keys.d=false"
      >
        â†’
      </button>
    </div>
    <div id="gameContainer">
      <div class="moveEria">
        <p id="UIText"></p>
        <input type="button" class="itemList" value="ãƒã‚¿ã‚¹ã‚³" />
        <input type="button" class="itemList" value="å¤¢" />
      </div>
      <div class="player" id="player"></div>
      <input type="button" class="action" value="âš”Attack" />
      <input type="button" class="action" value="ğŸ“¶action" />
      <input type="button" class="action" value="ğŸ›item" />
      <input type="button" class="action" value="âœ–mercy" />
      <p class="UI" id="name">Name</p>
      <p class="UI" id="level">LV 1</p>
      <p class="UI" id="hpLabel">HP</p>
      <div class="hpbar" id="hpbarback"></div>
      <div class="hpbar" id="hpbar"></div>
      <div class="bosshpbar" id="bosshpbarback"></div>
      <div class="bosshpbar" id="bosshpbar"></div>
      <div id="attackNote"></div>
      <div class="enemy"></div>
    </div>
    <div id="titleContainer">
      <h1 class="title">No Title</h1>
      <input type="button" class="titleAction" value="play" />
      <input type="button" class="titleAction" value="operation" />
      <input type="button" class="titleAction" id="back" value="back" />
      <h1 class="title" id="gameOverText" style="display: none">Game Over</h1>
      <h1 class="title" style="display: none">Operation</h1>
      <h1 class="title" style="display: none">Game Clear</h1>
      <h1 id="titleContent" style="display: none">WASD = ç§»å‹•</h1>
      <h1 id="resultContent" style="display: none">WASD = ç§»å‹•</h1>
    </div>

    <audio id="bgm" loop>
      <source src="sounds/Roland BOSS Concert.mp3" type="audio/mpeg" />
    </audio>
    <audio id="se">
      <source src="" type="audio/mpeg" />
    </audio>

    <script type="text/javascript">
      const titleContainer = document.getElementById("titleContainer");
      const gameContainer = document.getElementById("gameContainer");
      const hpbarback = document.getElementById("hpbarback");
      const bosshpbarback = document.getElementById("bosshpbarback");
      const hpbar = document.getElementById("hpbar");
      const bosshpbar = document.getElementById("bosshpbar");
      const player = document.querySelector(".player");
      const playerScene = document.getElementById("player");
      const moveEria = document.querySelector(".moveEria");
      const actionButtons = document.getElementsByClassName("action");
      const titleButtons = document.getElementsByClassName("titleAction");
      const titleButtonBack = document.getElementById("back");
      const title = document.getElementsByClassName("title");
      const UI = document.getElementsByClassName("UI");
      const enemy = document.getElementsByClassName("enemy");
      const bgm = document.getElementById("bgm");
      const se = document.getElementById("se");
      const titleContent = document.getElementById("titleContent");
      const resultContent = document.getElementById("resultContent");
      const UIText = document.getElementById("UIText");
      const itemList = document.getElementsByClassName("itemList");

      //options
      let MAXHP = 100; //player hp
      let attackStr = 10; //player Attack strength
      let speed = 2.3; //player Speed
      let MAXBOSSHP = 100;
      let noteAttackCount = 15; //pattern base Count
      let patternDirayTime = 1500; //ms
      const noteSpeed = 5; //note Speed
      let SoundVolume = { bgm: 0.15, se: 0.5 };
      let attackStrDebug = 0; //debugç”¨

      //åˆæœŸè¨­å®š
      let hitCount = 0;
      const baseWidth = 1920;
      const baseHeight = 1080;
      let scale = 1;
      const playerSize = 15;
      const eriaSize = { width: 150, height: 150 };
      const noteSize = { width: 50, height: 10 };
      const buttonSize = { width: 250, height: 100 };
      const uiSize = { width: 100, height: 30 };
      const setLimitEria = { x: 0, y: 100 };
      let limitEria = { x: baseWidth / 2, y: baseHeight / 2 + setLimitEria.y };
      const spawnRadius = 250;
      let x = limitEria.x;
      let y = limitEria.y;
      const keys = {};
      const selectkeys = {};
      let gameScene = "title";
      let animationFrameId = null;
      let selectButtonAnimationFrameId = null;
      let isShowItems = false;
      let avoidanceWidth = 0;
      let avoidanceHeight = 0;
      const baseUp = 50;
      enemy[0].style.display = "block";
      let gamepadIndex = null; // ä½¿ç”¨ã™ã‚‹ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
      document.getElementById("bgm").volume = SoundVolume.bgm;
      document.getElementById("se").volume = SoundVolume.se;
      let HP = MAXHP; //player hp
      let BossHP = MAXBOSSHP; //Boss HP
      let selectedButtonIndex = 0; // ç¾åœ¨é¸æŠä¸­ã®ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
      let itemSelectedButtonIndex = 0;
      let prevGameScene = null;
      let isTriggerPush = false;
      let gamepadPushes = []; // å„ãƒœã‚¿ãƒ³ã®æŠ¼ä¸‹çŠ¶æ…‹ã‚’è¨˜éŒ²
      let buttonState = []; // å„ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹å¤‰åŒ–ã‚’è¨˜éŒ²ï¼ˆæŠ¼ã—ãŸç¬é–“ã«ã ã‘åå¿œï¼‰
      let prevAxisX = 0; // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯Xè»¸
      let axisYState = null; // Yè»¸ã®çŠ¶æ…‹
      let axisXState = null; // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãŒå€’ã‚ŒãŸæ–¹å‘ã‚’è¨˜éŒ²
      const threshold = 0.5; // ã©ã‚Œãã‚‰ã„å€’ã—ãŸã‚‰åå¿œã™ã‚‹ã‹
      let Score = 10000;
      const textList = [
        ":ã‚ãªãŸã¯å‹•æºã—ã¦ã„ã‚‹",
        ":ã‚±ãƒ„ã‚¤ã‚’å›ºã‚ã‚",
        ":ã‚ãã‚‰ã‚ã‚‹ãª",
        ":ã¾ã å¸Œæœ›ã¯ã‚ã‚‹",
        ":è² ã‘ã‚‹ãª",
      ];

      // ãƒ‡ãƒã‚¦ãƒ³ã‚¹é–¢æ•°
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°ã®æ›´æ–°
      function updateScale() {
        const containerWidth = document.body.clientWidth;
        scale = containerWidth / baseWidth;
        console.log("ç”»é¢ã‚µã‚¤ã‚ºãŒå¤‰ã‚ã‚Šã¾ã—ãŸï¼å¹…:", containerWidth);
        updateLimitEria();
        updateElements();
      }

      // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹é©ç”¨ï¼‰
      const debouncedUpdateScale = debounce(updateScale, 100);
      window.addEventListener("resize", debouncedUpdateScale);

      function allReset() {
        // Reset core game variables
        speed = 2.3;
        HP = MAXHP;
        BossHP = MAXBOSSHP;
        x = limitEria.x;
        y = limitEria.y;
        gameScene = "title";
        avoidanceWidth = 0;
        avoidanceHeight = 0;
        selectedButtonIndex = 0;
        itemSelectedButtonIndex = 0;
        isShowItems = false;
        enemy[0].style.display = "block";
        enemy[0].style.opacity = "1"; // Reset enemy opacity
        attackStr = 10; // Reset attack strength

        // Stop all animations
        cancelAnimationFrame(animationFrameId);
        cancelAnimationFrame(selectButtonAnimationFrameId);
        animationFrameId = null;
        selectButtonAnimationFrameId = null;

        // Clear attack notes
        const attackNote = document.getElementById("attackNote");
        attackNote.innerHTML = "";

        // Reset UI text
        UIText.textContent = "";

        // Stop and reset BGM
        //bgm.currentTime = 0;
        //bgm.pause();

        // Reset scale and elements
        updateScale();
        updateSceneDisplay();
      }

      function posReset() {
        x = limitEria.x;
        y = limitEria.y;
      }

      function playSE(src) {
        se.src = src;
        se.play();
      }

      function updateElements() {
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        player.style.width = playerSize * scale + "px";
        player.style.height = playerSize * scale + "px";
        player.style.left = (x - playerSize / 2) * scale + "px";
        player.style.top = (y - playerSize / 2) * scale + "px";

        // ç§»å‹•ã‚¨ãƒªã‚¢
        moveEria.style.width = (eriaSize.width + avoidanceWidth) * scale + "px";
        moveEria.style.height = eriaSize.height * scale + "px";
        setEria(limitEria.x, limitEria.y);

        // HP
        hpbar.style.width = 3 * ((HP / MAXHP) * 100) * scale + "px";
        hpbar.style.height = 20 * scale + "px";
        hpbar.style.left = 1050 * scale + "px";
        hpbar.style.top = (785 - baseUp + 10) * scale + "px";
        hpbarback.style.width = 300 * scale + "px";
        hpbarback.style.height = 20 * scale + "px";
        hpbarback.style.left = 1050 * scale + "px";
        hpbarback.style.top = (785 - baseUp + 10) * scale + "px";

        //EnemyHP
        bosshpbar.style.width = 3 * ((BossHP / MAXBOSSHP) * 100) * scale + "px";
        bosshpbar.style.height = 20 * scale + "px";
        bosshpbar.style.left = (limitEria.x - 300 / 2) * scale + "px";
        bosshpbar.style.top = (450 - baseUp) * scale + "px";
        bosshpbarback.style.width = 300 * scale + "px";
        bosshpbarback.style.height = 20 * scale + "px";
        bosshpbarback.style.left = (limitEria.x - 300 / 2) * scale + "px";
        bosshpbarback.style.top = (450 - baseUp) * scale + "px";

        //Enemy
        enemy[0].style.width = 250 * scale + "px";
        enemy[0].style.height = 250 * scale + "px";
        enemy[0].style.left = (limitEria.x - 250 / 2) * scale + "px";
        enemy[0].style.top = (150 - baseUp) * scale + "px";

        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
        let width = -575;
        for (const item of actionButtons) {
          item.style.width = buttonSize.width * scale + "px";
          item.style.height = buttonSize.height * scale + "px";
          item.style.left = (baseWidth / 2 + width) * scale + "px";
          item.style.top = (baseHeight / 2 + 300 - baseUp) * scale + "px";
          item.style.fontSize = 50 * scale + "px";
          width += 300;
        }

        // ã‚¢ã‚¤ãƒ†ãƒ ãƒœã‚¿ãƒ³
        let widthitemlist = -100;
        for (const item of itemList) {
          item.style.width = 250 * scale + "px";
          item.style.height = 50 * scale + "px";
          item.style.left = (baseWidth / 2 + widthitemlist) * scale + "px";
          item.style.top = (baseHeight / 2 + 300 - baseUp) * scale + "px";
          item.style.fontSize = 25 * scale + "px";
          width += 320;
        }

        // UI
        let widthUI = -300;
        for (const item of UI) {
          item.style.width = uiSize.width * scale + "px";
          item.style.height = uiSize.height * scale + "px";
          item.style.left = (baseWidth / 2 + widthUI) * scale + "px";
          item.style.top = (baseHeight / 2 + 200 - baseUp + 10) * scale + "px";
          item.style.fontSize = 30 * scale + "px";
          if (item.id === "level") widthUI += 150;
          else if (item.id === "hpLabel") widthUI += 250;
          else widthUI += 100;
        }

        // ã‚¿ã‚¤ãƒˆãƒ«è¦ç´ 
        let heightTitle = 0;
        for (const item of titleButtons) {
          item.style.width = buttonSize.width * scale + "px";
          item.style.height = buttonSize.height * scale + "px";
          item.style.left = (baseWidth / 2 - 125) * scale + "px";
          item.style.top =
            (baseHeight / 2 + heightTitle - baseUp) * scale + "px";
          item.style.fontSize = 50 * scale + "px";
          heightTitle += 110;
        }

        titleButtonBack.style.width = buttonSize.width * scale + "px";
        titleButtonBack.style.height = buttonSize.height * scale + "px";
        titleButtonBack.style.left = (baseWidth / 2 - 125) * scale + "px";
        titleButtonBack.style.top =
          (baseHeight / 2 + heightTitle - baseUp) * scale + "px";

        title[0].style.left = (baseWidth / 2 - 125) * scale + "px";
        title[0].style.top = (baseHeight / 2 - 200 - baseUp) * scale + "px";
        title[0].style.fontSize = 60 * scale + "px";
        title[1].style.left = (baseWidth / 2 - 150) * scale + "px";
        title[1].style.top = (baseHeight / 2 - 200 - baseUp) * scale + "px";
        title[1].style.fontSize = 60 * scale + "px";
        title[2].style.left = (baseWidth / 2 - 240) * scale + "px";
        title[2].style.top = (baseHeight / 2 - 500 - baseUp) * scale + "px";
        title[2].style.fontSize = 60 * scale + "px";
        title[3].style.left = (baseWidth / 2 - 190) * scale + "px";
        title[3].style.top = (baseHeight / 2 - 200 - baseUp) * scale + "px";
        title[3].style.fontSize = 60 * scale + "px";

        titleContent.style.left = (baseWidth / 2 - 200) * scale + "px";
        titleContent.style.top = (baseHeight / 2 - 300 - baseUp) * scale + "px";
        titleContent.style.fontSize = 60 * scale + "px";

        resultContent.style.left = (baseWidth / 2 - 320) * scale + "px";
        resultContent.style.top = (baseHeight / 2 - baseUp) * scale + "px";
        resultContent.style.fontSize = 60 * scale + "px";
      }

      // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      for (const item of actionButtons) {
        item.addEventListener("click", function () {
          console.log(item.value);
          if (BossHP > 0) {
            if (item.value === "âœ–mercy" && gameScene !== "avoidance") {
              playSE("sounds/select.mp3");
              gamepadPushes.fill(false);
              allReset(); // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
              gameScene = "title"; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«é·ç§»
              updateSceneDisplay(); // ç”»é¢ã‚’æ›´æ–°
            } else if (gameScene !== "avoidance") {
              if (item.value === "âš”Attack") {
                BossHP -= attackStr + attackStrDebug;
                playSE("sounds/attack.mp3");
                if (BossHP <= 0) {
                  gameScene = "action"; // Changed from "clear" to "action"
                  bgm.pause(); // BGMã‚’åœæ­¢
                  bgm.currentTime = 0;
                  cancelAnimationFrame(animationFrameId); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                  const attackNote = document.getElementById("attackNote");
                  attackNote.innerHTML = ""; // æ”»æ’ƒãƒãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢
                  // Fade out the enemy
                  enemy[0].style.opacity = "0"; // Start the fade-out effect
                  setTimeout(() => {
                    enemy[0].style.display = "none"; // Hide the enemy after fading
                    gamepadPushes.fill(false);
                    allReset(); // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
                    gameScene = "gameClear"; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«é·ç§»
                    updateSceneDisplay(); // ç”»é¢ã‚’æ›´æ–°
                  }, 1000); // Match the transition duration (1s = 1000ms)
                  // Optionally reset BossHP or other states if needed
                  avoidanceWidth = 900; // Ensure action state dimensions
                  avoidanceHeight = 0;
                  for (const item of itemList) item.style.display = "none";
                  UIText.textContent = "ãƒœã‚¹ã‚’å€’ã—ãŸï¼"; // Optional message
                  updateElements();
                  return;
                }
                enemy[0].style.backgroundColor = "red";
                setTimeout(() => {
                  enemy[0].style.backgroundColor = "white";
                }, 100);
                gameScene = "avoidance";
                isShowItems = false;
                updateSceneDisplay();
              } else if (item.value === "ğŸ›item") {
                playSE("sounds/select.mp3");
                if (isShowItems) {
                  isShowItems = false;
                } else {
                  isShowItems = true;
                }
                updateSceneDisplay();
              } else if (item.value === "ğŸ“¶action") {
                playSE("sounds/select.mp3");
                isShowItems = false;
                actionNumfun();
              } else {
                playSE("sounds/select.mp3");
                gameScene = "avoidance";
                isShowItems = false;
                updateSceneDisplay();
              }
            }
          }
        });
      }

      function actionNumfun() {
        let actionNum = Math.floor(Math.random() * 2);
        avoidanceHeight = 0;
        for (const item of itemList) item.style.display = "none";
        updateElements();
        switch (actionNum) {
          case 0:
            UIText.textContent = "ã“ã¶ã—ã«åŠ›ã‚’è¾¼ã‚ãŸ";
            attackStr += 2;
            setTimeout(() => {
              UIText.textContent = `æ”»æ’ƒåŠ›ãŒ2ä¸Šæ˜‡ã—ãŸ`;
            }, 500);
            break;
          case 1:
            UIText.textContent = "ã‚±ãƒ„ã‚¤ã‚’æ±ºã‚ãŸ";
            HP += 30;
            setTimeout(() => {
              UIText.textContent = `ä½“åŠ›ãŒ30å›å¾©ã—ãŸ`;
            }, 500);
            playSE("sounds/heal.mp3");
            break;
        }
        if (HP > MAXHP) {
          HP = MAXHP;
        }
        setTimeout(() => {
          gameScene = "avoidance";
          updateSceneDisplay();
        }, 1000);
      }

      // ã‚¿ã‚¤ãƒˆãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      for (const item of titleButtons) {
        item.addEventListener("click", function () {
          console.log(item.value);
          if (item.value === "play") {
            allReset();
            Score = 10000;
            hitCount = 0;
            gameScene = "action";
            updateSceneDisplay();
          } else if (item.value === "operation") {
            gameScene = "operation";
            updateSceneDisplay();
          } else if (item.value === "back") {
            gameScene = "title";
            updateSceneDisplay();
          }
          playSE("sounds/select.mp3");
        });
      }

      // ã‚¢ã‚¤ãƒ†ãƒ ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      for (const item of itemList) {
        item.addEventListener("click", function () {
          console.log(item.value);
          if (item.value == "ãƒã‚¿ã‚¹ã‚³") {
            HP += 30;
          } else if (item.value == "å¤¢") {
            HP += 20;
          }
          if (HP > 100) {
            HP = 100;
          }
          isShowItems = false;
          playSE("sounds/heal.mp3");
          gameScene = "avoidance";
          updateSceneDisplay();
        });
      }

      function updateSceneDisplay() {
        if (gameScene === "avoidance") {
          posReset();
          titleContainer.style.display = "none";
          gameContainer.style.display = "block";
          avoidanceWidth = 0;
          avoidanceHeight = 0;
          for (const item of itemList) item.style.display = "none";
          playerScene.style.display = "block";
          moveEria.style.display = "block";
          for (const item of actionButtons) item.style.display = "block";
          for (const item of UI) item.style.display = "block";
          hpbar.style.display = "block";
          hpbarback.style.display = "block";
          title[0].style.display = "block";
          title[1].style.display = "none";
          title[2].style.display = "none";
          titleContent.style.display = "none";
          resultContent.style.display = "none";
          UIText.textContent = "";
          updateLimitEria();
          // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ã‚²ãƒ¼ãƒ ç”»é¢ã«è¨­å®š
          document.body.focus();
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•é–‹å§‹
          movePlayer();
          setTimeout(() => {
            createNote();
          }, 500);
          selectButton();
          updateElements();
        } else if (gameScene === "action") {
          console.log("playsound");
          bgm.play();
          titleContainer.style.display = "none";
          gameContainer.style.display = "block";
          avoidanceWidth = 900;
          playerScene.style.display = "none";
          moveEria.style.display = "block";
          for (const item of actionButtons) item.style.display = "block";
          for (const item of UI) item.style.display = "block";
          hpbar.style.display = "block";
          hpbarback.style.display = "block";
          title[0].style.display = "block";
          title[1].style.display = "none";
          title[2].style.display = "none";
          title[3].style.display = "none";
          titleContent.style.display = "none";
          resultContent.style.display = "none";
          cancelAnimationFrame(animationFrameId);
          const attackNote = document.getElementById("attackNote");
          attackNote.innerHTML = "";
          let textRnd = Math.floor(Math.random() * textList.length);
          UIText.textContent = textList[textRnd];
          if (isShowItems) {
            UIText.textContent = "";
            avoidanceHeight = 100;
            for (const item of itemList) item.style.display = "block";
          } else {
            avoidanceHeight = 0;
            for (const item of itemList) item.style.display = "none";
          }
          selectButton();
          updateElements();
        } else if (gameScene === "title") {
          bgm.pause(); // BGMã‚’åœæ­¢
          bgm.currentTime = 0;
          titleContainer.style.display = "block";
          gameContainer.style.display = "none";
          titleButtons[0].style.display = "block";
          titleButtons[1].style.display = "block";
          titleButtonBack.style.display = "none";
          title[0].style.display = "block";
          title[1].style.display = "none";
          title[2].style.display = "none";
          title[3].style.display = "none";
          titleContent.style.display = "none";
          resultContent.style.display = "none";
          selectButton();
          updateElements();
        } else if (gameScene === "gameOver") {
          bgm.pause(); // BGMã‚’åœæ­¢
          bgm.currentTime = 0;
          resultContent.innerHTML = `Hitå›æ•°: ${hitCount}<br>ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: ${Score}`;
          titleContainer.style.display = "block";
          gameContainer.style.display = "none";
          titleButtons[0].style.display = "none";
          titleButtons[1].style.display = "none";
          titleButtonBack.style.display = "block";
          title[0].style.display = "none";
          title[1].style.display = "block";
          title[2].style.display = "none";
          title[3].style.display = "none";
          titleContent.style.display = "none";
          resultContent.style.display = "block";
          selectButton();
          updateElements();
        } else if (gameScene === "gameClear") {
          console.log(hitCount);
          resultContent.innerHTML = `Hitå›æ•°: ${hitCount}<br>ã‚ãªãŸã®ã‚¹ã‚³ã‚¢: ${Score}`;
          bgm.pause(); // BGMã‚’åœæ­¢
          bgm.currentTime = 0;
          titleContainer.style.display = "block";
          gameContainer.style.display = "none";
          titleButtons[0].style.display = "none";
          titleButtons[1].style.display = "none";
          titleButtonBack.style.display = "block";
          title[0].style.display = "none";
          title[1].style.display = "none";
          title[2].style.display = "none";
          title[3].style.display = "block";
          titleContent.style.display = "none";
          resultContent.style.display = "block";
          selectButton();
          updateElements();
        } else if (gameScene === "operation") {
          bgm.pause(); // BGMã‚’åœæ­¢
          bgm.currentTime = 0;
          titleContainer.style.display = "block";
          gameContainer.style.display = "none";
          titleButtons[0].style.display = "none";
          titleButtons[1].style.display = "none";
          titleButtonBack.style.display = "block";
          title[0].style.display = "none";
          title[1].style.display = "none";
          title[2].style.display = "none";
          title[3].style.display = "none";
          titleContent.style.display = "block";
          resultContent.style.display = "none";
          selectButton();
          updateElements();
        }
      }

      function movePlayer() {
        if (gameScene !== "avoidance") {
          cancelAnimationFrame(animationFrameId);
          return;
        }

        const halfWidth = (eriaSize.width + avoidanceWidth) / 2;
        const halfHeight = (eriaSize.height + avoidanceHeight) / 2;

        // ã‚­ãƒ¼å…¥åŠ›ï¼ˆWASDï¼‰
        let moveX = 0;
        let moveY = 0;
        if (keys.w) moveY -= speed;
        if (keys.s) moveY += speed;
        if (keys.a) moveX -= speed;
        if (keys.d) moveX += speed;

        // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰å…¥åŠ›
        if (gamepadIndex !== null) {
          const gamepad = navigator.getGamepads()[gamepadIndex];
          if (gamepad && gamepad.connected) {
            // å·¦ã‚¢ãƒŠãƒ­ã‚°ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼ˆaxes[0]: å·¦å³, axes[1]: ä¸Šä¸‹ï¼‰
            const stickX =
              Math.abs(gamepad.axes[0]) > deadZone ? gamepad.axes[0] : 0;
            const stickY =
              Math.abs(gamepad.axes[1]) > deadZone ? gamepad.axes[1] : 0;

            // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å…¥åŠ›ã«åŸºã¥ã„ã¦ç§»å‹•é‡ã‚’è¨ˆç®—
            moveX += stickX * speed;
            moveY += stickY * speed;
          }
        }

        // ç§»å‹•é‡ã‚’é©ç”¨
        x += moveX;
        y += moveY;

        // ç§»å‹•ã‚¨ãƒªã‚¢å†…ã«åˆ¶é™
        x = Math.max(
          limitEria.x - halfWidth,
          Math.min(x, limitEria.x + halfWidth - playerSize)
        );
        y = Math.max(
          limitEria.y - halfHeight,
          Math.min(y, limitEria.y + halfHeight - playerSize)
        );

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’æ›´æ–°
        player.style.left = x * scale + "px";
        player.style.top = y * scale + "px";
        animationFrameId = requestAnimationFrame(movePlayer);
      }

      function selectButton() {
        // ã‚·ãƒ¼ãƒ³ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã«åˆæœŸåŒ–
        let gamepadbutton = null;
        if (gamepadIndex !== null) {
          const gamepad = navigator.getGamepads()[gamepadIndex];
          if (!gamepad) return;
          gamepad.buttons[0] = false;

          // ãƒœã‚¿ãƒ³å‡¦ç†
          for (let i = 0; i < gamepad.buttons.length; i++) {
            const isPressed = gamepad.buttons[i].pressed;

            // æŠ¼ã—ãŸç¬é–“ã®ã¿åå¿œï¼ˆé•·æŠ¼ã—ç„¡è¦–ï¼‰
            if (isPressed !== gamepadPushes[i]) {
              gamepadPushes[i] = isPressed; // çŠ¶æ…‹ã‚’æ›´æ–°

              if (isPressed) {
                console.log(`ãƒœã‚¿ãƒ³${i}ã‚’æŠ¼ã—ãŸï¼`);

                // ãƒœã‚¿ãƒ³0ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã€ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã®ä»£ã‚ã‚Šã«ä½¿ã†
                if (i === 0) {
                  selectkeys.space = true;
                }
              } else {
                // ãƒœã‚¿ãƒ³0ãŒé›¢ã•ã‚ŒãŸå ´åˆ
                if (i === 0) {
                  selectkeys.space = false;
                }
              }
            }
          }
          // ã‚¹ãƒ†ã‚£ãƒƒã‚¯å‡¦ç†
          const axisX = gamepad.axes[0]; // -1ï½+1ã®ç¯„å›²
          const axisY = gamepad.axes[1]; // -1ï½+1ã®ç¯„å›²

          // å³ã«å€’ã—ãŸç¬é–“ (Xè»¸)
          if (axisX > threshold && axisXState !== "right") {
            console.log("å³ã«å€’ã—ãŸï¼");
            selectkeys.d = true;
            axisXState = "right"; // å³ã«å€’ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
          }

          // å·¦ã«å€’ã—ãŸç¬é–“ (Xè»¸)
          if (axisX < -threshold && axisXState !== "left") {
            console.log("å·¦ã«å€’ã—ãŸï¼");
            selectkeys.a = true;
            axisXState = "left"; // å·¦ã«å€’ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
          }

          // ä¸Šã«å€’ã—ãŸç¬é–“ (Yè»¸)
          if (axisY > threshold && axisYState !== "up") {
            console.log("ä¸Šã«å€’ã—ãŸï¼");
            selectkeys.w = true;
            axisYState = "up"; // ä¸Šã«å€’ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
          }

          // ä¸‹ã«å€’ã—ãŸç¬é–“ (Yè»¸)
          if (axisY < -threshold && axisYState !== "down") {
            console.log("ä¸‹ã«å€’ã—ãŸï¼");
            selectkeys.s = true;
            axisYState = "down"; // ä¸‹ã«å€’ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
          }

          // çœŸã‚“ä¸­ã«æˆ»ã—ãŸç¬é–“ (Xè»¸ã¨Yè»¸)
          if (Math.abs(axisX) < threshold && axisXState !== null) {
            console.log("Xã‚¹ãƒ†ã‚£ãƒƒã‚¯æˆ»ã—ãŸï¼");
            selectkeys.d = false;
            selectkeys.a = false;
            axisXState = null; // Xã‚¹ãƒ†ã‚£ãƒƒã‚¯ãŒæˆ»ã£ãŸã“ã¨ã‚’è¨˜éŒ²
          }

          if (Math.abs(axisY) < threshold && axisYState !== null) {
            console.log("Yã‚¹ãƒ†ã‚£ãƒƒã‚¯æˆ»ã—ãŸï¼");
            selectkeys.w = false;
            selectkeys.s = false;
            axisYState = null; // Yã‚¹ãƒ†ã‚£ãƒƒã‚¯ãŒæˆ»ã£ãŸã“ã¨ã‚’è¨˜éŒ²
          }
        }
        if (prevGameScene !== gameScene) {
          if (gameScene === "title") {
            for (const item of titleButtons)
              item.style.border = "4px solid orange";
            selectedButtonIndex = 0;
            titleButtons[selectedButtonIndex].style.border = "4px solid red";
          } else if (gameScene === "operation" || gameScene === "gameOver") {
            titleButtons[selectedButtonIndex].style.border = "4px solid red";
          } else if (gameScene === "action") {
            for (const item of actionButtons)
              item.style.border = "4px solid orange";
            itemSelectedButtonIndex = 0;
            actionButtons[itemSelectedButtonIndex].style.border =
              "4px solid red";
          }
          prevGameScene = gameScene;
        }
        // ä¸Šã«ç§»å‹• (wã‚­ãƒ¼)
        if (selectkeys.w) {
          if (gameScene === "title") {
            for (const item of titleButtons)
              item.style.border = "4px solid orange";
            selectedButtonIndex++;
            if (selectedButtonIndex >= 2) {
              selectedButtonIndex = 0;
            }
            titleButtons[selectedButtonIndex].style.border = "4px solid red";
            console.log(selectedButtonIndex);
          }
          if (gameScene === "action") {
            for (const item of itemList) item.style.border = "4px solid orange";
            itemSelectedButtonIndex--;
            if (itemSelectedButtonIndex < 0) {
              itemSelectedButtonIndex = itemList.length - 1;
            }
            itemList[itemSelectedButtonIndex].style.border = "4px solid red";
            console.log(itemSelectedButtonIndex);
          }
          selectkeys.w = false; // é€£ç¶šç§»å‹•é˜²æ­¢ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        }

        // ä¸‹ã«ç§»å‹• (sã‚­ãƒ¼)
        if (selectkeys.s) {
          if (gameScene === "title") {
            for (const item of titleButtons)
              item.style.border = "4px solid orange";
            selectedButtonIndex--;
            if (selectedButtonIndex < 0) {
              selectedButtonIndex = 1;
            }
            titleButtons[selectedButtonIndex].style.border = "4px solid red";
            console.log(selectedButtonIndex);
          }
          if (gameScene === "action") {
            for (const item of itemList) item.style.border = "4px solid orange";
            itemSelectedButtonIndex++;
            if (itemSelectedButtonIndex >= itemList.length) {
              itemSelectedButtonIndex = 0;
            }
            itemList[itemSelectedButtonIndex].style.border = "4px solid red";
            console.log(itemSelectedButtonIndex);
          }
          selectkeys.s = false; // é€£ç¶šç§»å‹•é˜²æ­¢ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        }

        // å³ã«ç§»å‹• (wã‚­ãƒ¼)
        if (selectkeys.a) {
          if (gameScene === "action") {
            for (const item of actionButtons)
              item.style.border = "4px solid orange";
            selectedButtonIndex--;
            if (selectedButtonIndex < 0) {
              selectedButtonIndex = actionButtons.length - 1;
            }
            actionButtons[selectedButtonIndex].style.border = "4px solid red";
            console.log(selectedButtonIndex);
          }
          selectkeys.a = false; // é€£ç¶šç§»å‹•é˜²æ­¢ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        }

        // å·¦ã«ç§»å‹• (sã‚­ãƒ¼)
        if (selectkeys.d) {
          if (gameScene === "action") {
            for (const item of actionButtons)
              item.style.border = "4px solid orange";
            selectedButtonIndex++;
            if (selectedButtonIndex >= actionButtons.length) {
              selectedButtonIndex = 0;
            }
            actionButtons[selectedButtonIndex].style.border = "4px solid red";
            console.log(selectedButtonIndex);
          }
          selectkeys.d = false; // é€£ç¶šç§»å‹•é˜²æ­¢ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
        }
        // ãƒœã‚¿ãƒ³ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ– (spaceã‚­ãƒ¼)
        if (selectkeys.space || selectkeys.enter) {
          if (gameScene === "title") {
            titleButtons[selectedButtonIndex].click();
          } else if (gameScene === "action") {
            if (!isShowItems) {
              actionButtons[selectedButtonIndex].click();
              selectedButtonIndex = 0;
            } else {
              itemList[selectedButtonIndex].click();
              selectedButtonIndex = 0;
            }
          } else if (
            gameScene === "operation" ||
            gameScene === "gameOver" ||
            gameScene === "gameClear"
          ) {
            if (selectedButtonIndex == 2) {
              gamepadPushes.fill(false);
              allReset(); // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
              gameScene = "title"; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«é·ç§»
              updateSceneDisplay(); // ç”»é¢ã‚’æ›´æ–°
            }
            titleButtonBack.style.border = "4px solid red";
            selectedButtonIndex = 2;
          }
          selectkeys.space = false; // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆã¯1å›ã ã‘
          selectkeys.enter = false;
        }
        selectButtonAnimationFrameId = requestAnimationFrame(selectButton);
      }

      function setEria(x, y) {
        const halfWidth = (eriaSize.width + avoidanceWidth) / 2;
        const halfHeight = (eriaSize.height + avoidanceHeight) / 2;

        moveEria.style.left = (x - halfWidth - 6 / scale) * scale + "px";
        moveEria.style.top = (y - halfHeight - 6 / scale) * scale + "px";
        moveEria.style.width = (eriaSize.width + avoidanceWidth) * scale + "px";
        moveEria.style.height =
          (eriaSize.height + avoidanceHeight) * scale + "px";
      }

      function updateLimitEria() {
        limitEria = {
          x: baseWidth / 2 + setLimitEria.x,
          y: baseHeight / 2 + setLimitEria.y,
        };
        setEria(limitEria.x, limitEria.y);
      }

      function createNote() {
        const attackNote = document.getElementById("attackNote");
        const centerX = limitEria.x;
        const centerY = limitEria.y;
        const spawnInterval = 5; // æ¬¡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¾ã§ã®åŸºæœ¬é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        const totalDuration = Math.floor(Math.random() * 6) + noteAttackCount; // æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚ºã®åˆè¨ˆå›æ•°ï¼ˆãƒŸãƒªç§’ï¼‰
        let spawnCount = 0;
        let activeNotes = 0; // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒãƒ¼ãƒˆã®æ•°
        let isPatternRunning = false; // ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè¡Œä¸­ãƒ•ãƒ©ã‚°
        const currentDistance = 350;

        // å˜ä¸€ã®ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
        function createSingleNote(startX, startY, vx, vy) {
          const note = document.createElement("div");
          note.className = "attackNote";
          attackNote.appendChild(note);

          note.style.left = (startX - noteSize.width / 2) * scale + "px";
          note.style.top = startY * scale + "px";
          note.style.width = noteSize.width * scale + "px";
          note.style.height = noteSize.height * scale + "px";

          const rotation = (Math.atan2(vy, vx) * 180) / Math.PI;
          note.style.transform = `rotate(${rotation}deg)`;

          activeNotes++; // ãƒãƒ¼ãƒˆç”Ÿæˆæ™‚ã«ã‚«ã‚¦ãƒ³ãƒˆå¢—
          return { note, posX: startX, posY: startY };
        }

        // ãƒãƒ¼ãƒˆã®ç§»å‹•ã¨è¡çªåˆ¤å®šã‚’å‡¦ç†ã™ã‚‹é–¢æ•°
        function moveNote(noteObj, vx, vy) {
          const { note, posX: initialX, posY: initialY } = noteObj;
          let posX = initialX;
          let posY = initialY;

          const moveInterval = setInterval(() => {
            posX += vx;
            posY += vy;
            note.style.left =
              (posX - (noteObj.size?.width || 0) / 2) * scale + "px";
            note.style.top =
              (posY - (noteObj.size?.height || 0) / 2) * scale + "px";

            if (checkCollision(note)) {
              hitCount++;
              Score -= 10;
              playSE("sounds/damage.mp3");
              console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãƒãƒ¼ãƒˆãŒè¡çªã—ã¾ã—ãŸï¼");
              HP = Math.max(0, HP - 2);
              updateElements();
              clearInterval(moveInterval);
              note.remove();
              activeNotes--; // ãƒãƒ¼ãƒˆå‰Šé™¤æ™‚ã«ã‚«ã‚¦ãƒ³ãƒˆæ¸›
              checkPatternCompletion(false); // è¡çªæ™‚ã¯æ¬¡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å³åº§ã«é–‹å§‹ã—ãªã„
              if (HP <= 0) {
                gameScene = "gameOver";
                bgm.pause(); // BGMã‚’åœæ­¢
                bgm.currentTime = 0;
                cancelAnimationFrame(animationFrameId); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                const attackNote = document.getElementById("attackNote");
                attackNote.innerHTML = ""; // æ”»æ’ƒãƒãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢
                updateSceneDisplay();
                return;
              }
            }
          }, 16);

          setTimeout(() => {
            clearInterval(moveInterval);
            note.remove();
            activeNotes--; // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã«ã‚‚ã‚«ã‚¦ãƒ³ãƒˆæ¸›
            checkPatternCompletion(true); // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³å®Œäº†ã‚’ãƒã‚§ãƒƒã‚¯
            console.log("Note timeout");
          }, 1500);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯
        function checkPatternCompletion(isTimeout = false) {
          if (HP <= 0 || BossHP <= 0) {
            return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
          }
        }

        const notePatterns = [
          spawnPattern1,
          spawnPattern2,
          spawnPattern2,
          spawnPattern2,
          spawnPattern3,
          spawnPattern3,
          spawnPattern4,
          spawnPattern5,
          spawnPattern5,
        ];

        function spawnNotes() {
          if (spawnCount >= totalDuration && gameScene == "avoidance") {
            console.log("æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚ºçµ‚äº†");
            gameScene = "action";
            updateSceneDisplay();
            return;
          }

          if (gameScene === "avoidance") {
            isPatternRunning = true;
            const selectPattern = Math.floor(
              Math.random() * notePatterns.length
            );
            console.log(`é¸æŠã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³: ${selectPattern}`);
            notePatterns[selectPattern]();
            spawnCount++;
            setTimeout(spawnNotes, patternDirayTime); // 1.5ç§’å¾Œã«æ¬¡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‘¼ã³å‡ºã—
          }
        }

        // æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹
        if (gameScene === "avoidance") {
          spawnNotes();
        }

        // ãƒãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³1: ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦ã§5ã¤ã®ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        function spawnPattern1() {
          for (let i = 0; i < Math.floor(Math.random() * 4) + 3; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const startX = centerX + spawnRadius * Math.cos(angle);
            const startY = centerY + spawnRadius * Math.sin(angle);

            const dx = x - startX;
            const dy = y - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const vx = (dx / distance) * noteSpeed;
            const vy = (dy / distance) * noteSpeed;

            const noteObj = createSingleNote(startX, startY, vx, vy);
            moveNote(noteObj, vx, vy);
          }
        }

        // ãƒãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³2: å›ºå®šä½ç½®ã‹ã‚‰5ã¤ã®ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        function spawnPattern2() {
          const halfWidth = (eriaSize.width + avoidanceWidth) / 2;
          const halfHeight = (eriaSize.height + avoidanceHeight) / 2;
          const buffer = 200;

          for (let i = 0; i < Math.floor(Math.random() * 4) + 3; i++) {
            let startX, startY, vx, vy;
            const side = Math.floor(Math.random() * 4);

            switch (side) {
              case 0:
                startX = limitEria.x - halfWidth - buffer;
                startY = limitEria.y + (Math.random() * 2 - 1) * halfHeight;
                vx = noteSpeed;
                vy = 0;
                break;
              case 1:
                startX = limitEria.x + halfWidth + buffer;
                startY = limitEria.y + (Math.random() * 2 - 1) * halfHeight;
                vx = -noteSpeed;
                vy = 0;
                break;
              case 2:
                startX = limitEria.x + (Math.random() * 2 - 1) * halfWidth;
                startY = limitEria.y - halfHeight - buffer;
                vx = 0;
                vy = noteSpeed;
                break;
              case 3:
                startX = limitEria.x + (Math.random() * 2 - 1) * halfWidth;
                startY = limitEria.y + halfHeight + buffer;
                vx = 0;
                vy = -noteSpeed;
                break;
            }

            const noteObj = createSingleNote(startX, startY, vx, vy);
            moveNote(noteObj, vx, vy);
          }
        }

        function spawnPattern3() {
          playSE("sounds/beamset.mp3");
          const halfWidth = (eriaSize.width + avoidanceWidth) / 2;
          const halfHeight = (eriaSize.height + avoidanceHeight) / 2;
          const buffer = 330;
          const beamSpeed = noteSpeed * 2;
          const beamNoteSize = { width: 200, height: 10 };
          const moveDelay = 800;

          for (let i = 0; i < 4; i++) {
            let startX, startY, vx, vy;
            const side = Math.floor(Math.random() * 2);

            switch (side) {
              case 0:
                startX =
                  limitEria.x -
                  beamNoteSize.width / 2 -
                  halfWidth -
                  buffer +
                  100;
                startY = limitEria.y + (Math.random() * 2 - 1) * halfHeight;
                vx = beamSpeed;
                vy = 0;
                break;
              case 1:
                startX =
                  limitEria.x -
                  beamNoteSize.width / 2 +
                  halfWidth +
                  buffer +
                  100;
                startY = limitEria.y + (Math.random() * 2 - 1) * halfHeight;
                vx = -beamSpeed;
                vy = 0;
                break;
            }

            // ãƒ“ãƒ¼ãƒ ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
            const note = document.createElement("div");
            note.className = "beamNote";
            document.getElementById("attackNote").appendChild(note);

            note.style.left = startX * scale + "px";
            note.style.top = startY * scale + "px";
            note.style.width = beamNoteSize.width * scale + "px";
            note.style.height = beamNoteSize.height * scale + "px";

            // äºˆæ¸¬ç·šã®ç”Ÿæˆ
            const noteAria = document.createElement("div");
            noteAria.className = "beamNoteAria";
            document.getElementById("attackNote").appendChild(noteAria);
            noteAria.style.left = startX * scale + "px";
            noteAria.style.top = startY * scale + "px";
            noteAria.style.width = beamNoteSize.width * scale * 5 + "px"; // äºˆæ¸¬ç·šã‚’é•·ã
            noteAria.style.height = beamNoteSize.height * scale + "px";
            noteAria.style.opacity = "0.5"; // åŠé€æ˜ã§è¦–èªæ€§ç¢ºä¿
            noteAria.style.backgroundColor = "rgba(255, 50, 50, 0.3)"; // èµ¤ã£ã½ã„è‰²ã§å±é™ºã‚’ç¤ºã™
            noteAria.style.transition = "opacity 0.3s"; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨

            // ãƒ“ãƒ¼ãƒ ã¨äºˆæ¸¬ç·šã®å›è»¢
            const rotation = (Math.atan2(vy, vx) * 180) / Math.PI;
            note.style.transform = `rotate(${rotation}deg)`;
            noteAria.style.transform = `rotate(${rotation}deg)`;

            activeNotes++; // ãƒ“ãƒ¼ãƒ ã‚‚ã‚«ã‚¦ãƒ³ãƒˆ
            const noteObj = { note, posX: startX, posY: startY };

            // äºˆæ¸¬ç·šã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ç§»å‹•å‡¦ç†
            setTimeout(() => {
              // ãƒ“ãƒ¼ãƒ ç§»å‹•é–‹å§‹æ™‚ã«äºˆæ¸¬ç·šã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
              noteAria.style.opacity = "0";
              moveNote(noteObj, vx, vy);
              // äºˆæ¸¬ç·šã‚’å°‘ã—é…ã‚Œã¦å®Œå…¨ã«å‰Šé™¤
              setTimeout(() => {
                noteAria.remove();
              }, 300);
            }, moveDelay);

            // äºˆæ¸¬ç·šã‚’ç‚¹æ»…ã•ã›ã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            let blinkCount = 0;
            const blinkInterval = setInterval(() => {
              noteAria.style.opacity = blinkCount % 2 === 0 ? "0.5" : "0.2";
              blinkCount++;
              if (blinkCount >= 6) clearInterval(blinkInterval); // 3å›ç‚¹æ»…ã—ãŸã‚‰çµ‚äº†
            }, 200);
          }
        }

        // ãƒãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³4: å††å½¢ã«é…ç½®ã—ã€é †ç•ªã«ä¸­å¿ƒã«å‘ã‹ã£ã¦ç§»å‹•
        function spawnPattern4() {
          const halfWidth = (eriaSize.width + avoidanceWidth) / 2;
          const halfHeight = (eriaSize.height + avoidanceHeight) / 2;
          const radius = Math.min(halfWidth, halfHeight) * 3;
          const noteCount = Math.floor(Math.random() * 11) + 10;
          const waitTime = 250;
          const moveDelay = 300;

          for (let i = 0; i < noteCount; i++) {
            playSE("sounds/noteset1.mp3");
            const angle = (i / noteCount) * 2 * Math.PI;
            const startX = limitEria.x + radius * Math.cos(angle);
            const startY = limitEria.y + radius * Math.sin(angle);

            const dx = centerX - startX;
            const dy = centerY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const vx = (dx / distance) * noteSpeed;
            const vy = (dy / distance) * noteSpeed;

            const noteObj = createSingleNote(startX, startY, vx, vy);
            setTimeout(() => {
              moveNote(noteObj, vx, vy);
            }, waitTime + i * moveDelay);
          }
        }

        function spawnPattern5() {
          playSE("sounds/beamset.mp3");
          const halfWidth = (eriaSize.width + avoidanceWidth) / 2;
          const halfHeight = (eriaSize.height + avoidanceHeight) / 2;
          const buffer = 330;
          const beamSpeed = noteSpeed * 2;
          const beamNoteSize = { width: 200, height: 10 };
          const moveDelay = 800;

          for (let i = 0; i < 4; i++) {
            let startX, startY, vx, vy;
            const side = Math.floor(Math.random() * 2);

            switch (side) {
              case 0: // Top
                startX = limitEria.x + (Math.random() * 2 - 1) * halfWidth;
                startY =
                  limitEria.y - beamNoteSize.height / 2 - halfHeight - buffer;
                vx = 0;
                vy = beamSpeed;
                break;
              case 1: // Bottom
                startX = limitEria.x + (Math.random() * 2 - 1) * halfWidth;
                startY =
                  limitEria.y + beamNoteSize.height / 2 + halfHeight + buffer;
                vx = 0;
                vy = -beamSpeed;
                break;
            }

            // ãƒ“ãƒ¼ãƒ ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
            const note = document.createElement("div");
            note.className = "beamNote";
            document.getElementById("attackNote").appendChild(note);
            startX += 100;
            note.style.left = (startX - beamNoteSize.width / 2) * scale + "px"; // Center horizontally
            note.style.top = (startY - beamNoteSize.height / 2) * scale + "px"; // Center vertically
            note.style.width = beamNoteSize.width * scale + "px";
            note.style.height = beamNoteSize.height * scale + "px";

            // äºˆæ¸¬ç·šã®ç”Ÿæˆ
            const noteAria = document.createElement("div");
            noteAria.className = "beamNoteAria";
            document.getElementById("attackNote").appendChild(noteAria);
            noteAria.style.left =
              (startX - beamNoteSize.width / 2) * scale + "px"; // Match note's centering
            noteAria.style.top =
              (startY - beamNoteSize.height / 2) * scale + "px";
            noteAria.style.width = beamNoteSize.width * scale * 5 + "px"; // Fixed: match beam width
            noteAria.style.height = beamNoteSize.height * scale + "px"; // Vertical prediction line
            noteAria.style.opacity = "0.5";
            noteAria.style.backgroundColor = "rgba(255, 50, 50, 0.3)";
            noteAria.style.transition = "opacity 0.3s";

            // ãƒ“ãƒ¼ãƒ ã¨äºˆæ¸¬ç·šã®å›è»¢
            const rotation = (Math.atan2(vy, vx) * 180) / Math.PI;
            note.style.transform = `rotate(${rotation}deg)`;
            noteAria.style.transform = `rotate(${rotation}deg)`;

            activeNotes++;
            const noteObj = {
              note,
              posX: startX,
              posY: startY,
              size: beamNoteSize,
            }; // Store size for moveNote

            // äºˆæ¸¬ç·šã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ç§»å‹•å‡¦ç†
            setTimeout(() => {
              noteAria.style.opacity = "0";
              moveNote(noteObj, vx, vy);
              setTimeout(() => {
                noteAria.remove();
              }, 300);
            }, moveDelay);

            // äºˆæ¸¬ç·šã‚’ç‚¹æ»…ã•ã›ã‚‹
            let blinkCount = 0;
            const blinkInterval = setInterval(() => {
              noteAria.style.opacity = blinkCount % 2 === 0 ? "0.5" : "0.2";
              blinkCount++;
              if (blinkCount >= 6) clearInterval(blinkInterval);
            }, 200);
          }
        }
      }

      function checkCollision(note) {
        const playerRect = player.getBoundingClientRect();
        const noteRect = note.getBoundingClientRect();

        return (
          playerRect.left < noteRect.right &&
          playerRect.right > noteRect.left &&
          playerRect.top < noteRect.bottom &&
          playerRect.bottom > noteRect.top
        );
      }

      document.body.addEventListener("keydown", (event) => {
        const key = event.key === " " ? "space" : event.key.toLowerCase(); // ã‚¹ãƒšãƒ¼ã‚¹ã‚’ "space" ã«å¤‰æ›
        keys[key] = true;
        console.log(`ã‚­ãƒ¼æŠ¼ä¸‹: ${event.key}`); // ãƒ‡ãƒãƒƒã‚°ç”¨
      });

      document.body.addEventListener("keyup", (event) => {
        const key = event.key === " " ? "space" : event.key.toLowerCase(); // ã‚¹ãƒšãƒ¼ã‚¹ã‚’ "space" ã«å¤‰æ›
        keys[key] = false;
        console.log(`ã‚­ãƒ¼è§£æ”¾: ${event.key}`); // ãƒ‡ãƒãƒƒã‚°ç”¨
      });

      document.body.addEventListener("keydown", (event) => {
        const key = event.key === " " ? "space" : event.key.toLowerCase();
        // ã‚­ãƒ¼ãŒæ—¢ã«æŠ¼ã•ã‚Œã¦ã„ã‚‹ï¼ˆtrueï¼‰å ´åˆã¯ç„¡è¦–
        if (isTriggerPush) {
          return;
        } else {
          isTriggerPush = true;
          selectkeys[key] = true;
        }
        console.log(`ã‚­ãƒ¼æŠ¼ä¸‹: ${event.key}`); // ãƒ‡ãƒãƒƒã‚°ç”¨
      });

      document.body.addEventListener("keyup", (event) => {
        const key = event.key === " " ? "space" : event.key.toLowerCase();
        isTriggerPush = false;
        selectkeys[key] = false;
        console.log(`ã‚­ãƒ¼è§£æ”¾: ${event.key}`); // ãƒ‡ãƒãƒƒã‚°ç”¨
      });

      // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æ¥ç¶šæ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆ
      window.addEventListener("gamepadconnected", (event) => {
        gamepadIndex = event.gamepad.index;
        console.log(`ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æ¥ç¶š: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${gamepadIndex}`);
      });

      // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰åˆ‡æ–­æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆ
      window.addEventListener("gamepaddisconnected", (event) => {
        if (gamepadIndex === event.gamepad.index) {
          gamepadIndex = null;
          console.log(`ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰åˆ‡æ–­: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${event.gamepad.index}`);
        }
      });

      // ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³è¨­å®šï¼ˆã‚¢ãƒŠãƒ­ã‚°ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å¾®å°ãªå…¥åŠ›ã‚’ç„¡è¦–ï¼‰
      const deadZone = 0.2;

      updateSceneDisplay();
      updateScale();
    </script>
  </body>
</html>
